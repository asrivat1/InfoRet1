#!/usr/local/bin/perl -w

############################################################
##  seg_examp1.prl
##
##  seg_examp1.prl < segment.data.train
## 
##
##  Example of how one may begin a simple version of this
##  program. Lines of text are read into a @test_lines array
##  of lines (with length measured in $numb_lines) until a 
##  blank line is reached. Then the lines in the previous 
##  segment are processed.  The array @real_lines stores the
##  values of the correct classifications for the given in-
##  put data, useful for comparison with the segment class-
##  ifications chosen by the program.
############################################################

my @test_lines = ( );    # the current line that we are testing
my @real_lines = ( );    # the correct classification for the current line
my $numb_lines = 0;      # the number of lines in the block that we testing

my $correct   = 0;       # number of correct classifications
my $incorrect = 0;       # number of incorrect classifications
my $line      = undef;
my $prev_blank = 0;
my $dist_BOS  = 0;

# print the first chunk of the ARFF file
open($file, '>', 'cat_data.arff');
print $file "\@RELATION segment\n
             \@ATTRIBUTE numb_lines integer\n
             \@ATTRIBUTE length integer \n
             \@ATTRIBUTE dist_BOS integer \n
             \@ATTRIBUTE init_spaces integer \n
             \@ATTRIBUTE init_tabs integer \n
             \@ATTRIBUTE prop_start_numeric real \n
             \@ATTRIBUTE prop_start_alpha real \n
             \@ATTRIBUTE proportion_strange real \n
             \@ATTRIBUTE first_ends_colon {TRUE, FALSE} \n
             \@ATTRIBUTE num_quoted integer \n
             \@ATTRIBUTE numbered real \n
             \@ATTRIBUTE email {TRUE, FALSE} \n
             \@ATTRIBUTE dashes real \n
             \@ATTRIBUTE prop_spaces real \n
             \@ATTRIBUTE hanging integer \n
             \@ATTRIBUTE prop_cap real \n
             \@ATTRIBUTE allcaps integer \n
             \@ATTRIBUTE US_city {TRUE, FALSE} \n
             \@ATTRIBUTE first_line_non_word {TRUE, FALSE} \n
             \@ATTRIBUTE class {NNHEAD, QUOTED, SIG, TABLE, GRAPHIC, HEADL, ADDRESS, ITEM, PTEXT}\n
             \@DATA\n";

while (defined ($line = <STDIN>))
{
    chomp $line;

    if ($line =~ /^#BLANK#/)
    {
        &process_segment if $numb_lines;     # if we are at a blank line then
                                                 # it is time to process the pre-
                                                 # vious block

        @test_lines  = ( );   # make sure that we clear memory here or else
        @real_lines  = ( );   #  these arrays may hold old data which will
        $numb_lines  = 0;     #  screw up calculations of their length

        # check if EOS
        if ($prev_blank)
        {
            $dist_BOS = 0;
        }
        $prev_blank = 1;
    }
    else
    {
        ($test_lines[ $numb_lines ]) = ($line =~ m/^[^\t]+\t(.*)/);
        ($real_lines[ $numb_lines ]) = ($line =~ m/^([^\t]+)\t/  );

        $numb_lines += 1;
        $prev_blank = 0;
        $dist_BOS += 1;
    }
}

############################################################
## Process segments by applying specialized detectors/
## classifiers to the array of the text lines in the segment 
############################################################


sub process_segment {
    my $cnt;
    $spaces = 0;
    $tabs = 0;
    $numeric = 0;
    $alpha = 0;
    $strange = 0;
    $total_length = 0;
    $colon = "FALSE";
    $quoted = 0;
    $numbered = 0;
    $email = "FALSE";
    $dashes = 0;
    $hanging = 0;
    $capital = 0;
    $allcaps = 0;
    $US_city = "FALSE";
    $first_non_word = "FALSE";

	for ($cnt = 0; $cnt < scalar @test_lines; $cnt++)
    {
        $spaces += length(($test_lines[$cnt] =~ /^( *)/)[0]);

        $tabs += length(($test_lines[$cnt] =~ /^(\t*)/)[0]);

        if ($test_lines[$cnt] =~ /^( *)[0-9]/) { $numeric += 1; }
        elsif ($test_lines[$cnt] =~ /^[A-Za-z]/) { $alpha += 1; }

        $strange += () = $test_lines[$cnt] =~ /[\W \toO]/g;
        $strange = 0 unless $strange;
        $total_length += length($test_lines[$cnt]);

        if ($test_lines[$cnt] =~ /[:]$/) { $colon = "TRUE"; }

        if ($test_lines[$cnt] =~ /^( *)(\t*)(.{0,3})(>|:)/) { $quoted += 1; }

        if ($test_lines[$cnt] =~ /^( *)(\t*)\(?(([0-9]+)|([A-Za-z]+))(.|)/) { $numbered += 1; }

        if ($test_lines[$cnt] =~ /.+\@.+\..+/) { $email = "TRUE"; }

        if ($test_lines[$cnt] =~ /^( *)(\t*)\-/) { $dashes += 1; }

        if ($cnt > 0 && length(($test_lines[$cnt] =~ /^( *)/)[0]) >
                length(($test_lines[$cnt - 1] =~ /^( *)/)[0]))
        {
            $hanging += 1;
        }

        if ($cnt > 0 && length(($test_lines[$cnt] =~ /^(\t*)/)[0]) >
                length(($test_lines[$cnt - 1] =~ /^(\t*)/)[0]))
        {
            $hanging += 1;
        }

        if ($test_lines[$cnt] =~ /^(\s*)[A-Z]/) { $capital += 1; }

        if ($test_lines[$cnt] =~ /^(\s*)[A-Z\s0-9\.:\-]+$/) { $allcaps += 1; }

        if ($test_lines[$cnt] =~ /.+, [A-Z][A-Z] [0-9]{5}/) { $US_city = "TRUE"; }
        
	}

    if ($test_lines[0] =~ /^[\W ]*$/) { $first_non_word = "TRUE"; }

    print $file $numb_lines, ",";
    print $file $total_length, ",";
    print $file $dist_BOS, ",";
    print $file $spaces, ",";
    print $file $tabs, ",";
    print $file $numeric / $numb_lines, ",";
    print $file $alpha / $numb_lines, ",";
    print $file $strange / $total_length, ",";
    print $file $colon, ",";
    print $file $quoted, ",";
    print $file $numbered / $numb_lines, ",";
    print $file $email, ",";
    print $file $dashes / $numb_lines, ",";
    print $file $spaces / $total_length, ",";
    print $file $hanging, ",";
    print $file $capital / $numb_lines, ",";
    print $file $allcaps, ",";
    print $file $US_city, ",";
    print $file $first_non_word, ",";
    print $file $real_lines[0], "\n";
}

